第一章：开始

1.while(std:cin >> value)读输入流，直到文件结束符(end-of-file)，在Windows中是Ctrl+Z+Enter。
2.输入输出流
      std::cout << "Hello world" << std::endl;
      int v0,v1;
      std::cin >> v0 >> v1;

第二章：变量和基本类型

当第一次使用变量时，再定义。

作用域操作符“::”用来说明想使用的作用域，当::左面为空时，即使用全局作用域。

##复合类型-引用和指针
复合类型：
声明语句应该由一个基本数据类型，和紧随其后的一个声明符列表组成。其中声明符一般指变量名，还有&、*等。*和&一次只修饰一个变量，即int* p和int *p的含义是一样的。

引用：
（1）用‘&’定义。
      例：int i,&j = i;//定义int变量i，定义int引用j绑定i
（2）定义的同时必须与一个对象绑定即初始化
（3）一般来说，引用与绑定的对象类型要相同。
    第一种例外：初始化常量引用时，允许用任意表达式作为初始值，基本数据类型可以不一样，只要该表达式的结果能转换成引用的类型即可。这时编译器用一个与引用同类型的临时量对象先暂存const对象并转换类型，然后将临时量赋给常量引用。
    常量引用，即对const的引用，引用被const修饰，被引用的对象不一定要有const修饰，常量引用不能改变其引用的变量的值，与引用对象本身是否是常量无关。
      int i;
      const int j;
      double k;
      const int &r1 = i;//非常量变量也可以用常量引用
      const int &r2 = j;//常量变量，只能用常量引用
      const int $r3 = k;//引用与被引用对象类型不同：const int temp = k; const int &r3 = temp;
（4）无法定义引用的引用，将会绑定到同一个对象
（5）引用本身不是一个对象，一旦定义了一个引用，就无法令其再绑定到另外的对象
（6）非常量引用的初始值必须为左值，常量引用的初始值可以是字面量。

指针：
（1）用‘*’定义。
（2）与内置类型相似，可以反复拷贝，无需在定义时赋初值。
（3）获取指针存放的地址，用取地址符‘&’
（4）访问指针指向的对象，用解引用符‘*’
（5）空指针，建议赋值为nullptr
（6）一般来说，指针和其指向的对象的类型应该一致。
    第一种例外：允许一个指向常量的指针指向一个非常量对象，但基本数据类型仍要一致。因为指针本身也是一个对象，修饰指针的const只能限定指针指向的地址不能修改，而被指向对象用const修饰，才能保证该对象不被修改。
      int i = 3;
      int *const p = &i;//i可以修改，p不能修改。另外注意const的位置，强调修饰的是指针本身
      const int j = 3;
      int *const p2 = &j;//常量只能用常量指针来指向，这时p2和j都不能修改。
      例：给指针赋值
      初始化时：
        int j = 1;
        int *p1 = &j;//将地址赋值给指针
        int *p2 = p1;//将指针的值，还是地址，赋给新的指针
      初始化后：
        int i = 3;
        int *p1, *p2;
        p1 = &i;//将i的地址赋给p1指针
        *p2 = i;//将i的值赋给p2指向的变量，但此处会报错，因为p2未初始化，没有确定指向的变量
 
多个修饰符连写：
(1）指向指针的指针：
      int i = 1;
      int *p = &i;
      int **p2 = &p;
(2) 指向指针的引用：（引用不是对象，所以不能定义指向引用的指针）
      int i = 2;
      int *p = &i;
      int *&r = p;//之后使用r就是使用p
注：面对比较复杂的指针或引用的声明语句时，将“基本数据类型”+“声明符列表”从右向左读有助于弄清含义。

const限定符：
（1）顶层const：表示指针本身是常量，也可以表示任意的对象是常量。
（2）底层const：表示指针指向的对象是一个常量。
     *注：指针既可以是顶层const，也可以是底层const。//const int *const p;第一个是底层，第二个是顶层。
（3）当执行对象的拷贝操作时，顶层const不受影响。而拷入拷出的对象都必须具有相同的底层const资格，或者将非常量转换为常量。
（4）常量表达式：指值不会改变并且在编译过程中就能得到计算结果的表达式。
      const int i = 3;//yes
      const int j = i + 2;//yes
      int k = 4;//no.没有用const修饰
      const int m = get_size();//no.值直到具体运行时才能得到
    用constexpr类型声明变量，让编译器方便验证是否为常量表达式。
      constexpr int s = size();//只有当size是一个constexpr函数时才是正确的语句
（5）字面值类型：常量表达式的值在编译时就要得到，所以constexpr修饰的类型要比较简单。
      算术类型、引用、指针都属于字面值类型。
      自定义类、IO库、string类不属于字面值类型。
      引用和指针被定义成constexpr时，初始值严格限制，如指针必须是nullptr或0或存储于某个固定地址中的对象。
      函数体内定义的变量一般不存储在固定地址，所以不能定义为constexpr，相反，函数体之外的对象都可以。另外函数可以定义一类有效范围超出函数本身的变量，可以定义为constexpr。
      constexpr定义指针时，仅对指针本身有效，即置为顶层const。
            const int *p1 = nullptr;//指向整型常量的指针
            constexpr int *p2 = nullptr;//指向整型的常量指针
            
2.5 处理类型
类型别名：
（1）定义：
      typedef double wages;//wages是double的同义词
      typedef double *p;//p是double* 的同义词
      using student_num = int;//student_num是int的同义词
            *注：typedef定义的是类型别名，引用&定义的是变量别名，两者不同。
（2）指针、常量和类型别名
      typedef char *pstring;
      const pstring cstr = 0;//cstr是指向char的常量指针
      const pstring *p;//p是一个指针，它的对象是指向char的常量指针，即p是指针的指针
      *注：不要随意把别名替换为本来的样子
            const pstring cstr = 0;//基本类型为const pstring，即声明了一个指向char的常量指针
            const char *cstr = 0;//基本类型为const char，即声明了一个指向const char的指针
            
auto类型说明符
（1）根据变量的初始值自动判断类型，即auto定义的变量必须有初始值。
      auto i = 0, *p = &i;//一条声明语句只有一个基本数据类型，所以声明的变量的初始值必须一致。
（2）对auto类型的初始值，为引用时，auto判断为引用的对象的类型。
（3）对auto类型的初始值，会被忽略掉顶层const属性，同时底层const会保存下来。
      如果希望判断出的auto类型是一个顶层const，需要用const明确指出。
      const auto f = ci;
（4）可以将引用的类型设为auto，初始值即被引用的对象的顶层const仍保留。
      auto &i = j;
      
decltype类型指示符
（1）作用：从表达式的类型推断出要定义的变量的类型，而不把表达式的值用来初始化该变量。
（2）与auto不同，decltype使用的表达式是变量时，返回该变量的类型，包括顶层const和引用。
      *注：引用从来都作为其所指对象的同义词出现，只有在decltype中例外。
（3）decltype返回引用类型的几种情况：
      int j = 3, &i = j, *p = &j;
      decltype(i) a;//使用的表达式为引用
      decltype(*p) b;//使用的表达式为解引用操作，这里得到int&
      decltype((i)) c;//使用的表达式为变量，但加上了一层或多层括号，被当作表达式，变量是一种可以作为赋值语句左值的特殊表达式，得到int&
                      //或者说，decltype使用双层括号时，结果永远是引用，单层括号只有表达式本身就是引用时结果才是引用
                      
2.6 自定义数据结构
自定义数据类型：
（1）定义：
      struct 类名{
            类体；
      };
（2）类内数据成员可以默认初始化，或者给一个类内初始值。
（3）编写头文件：保持一致性，通常包含那些只被定义一次的实体，如类、const、constexpr等，也经常用到其他头文件。
      *注：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。
（4）预处理器：处理一些预处理功能，在编译之前。
      #include
      #define
      头文件保护符：
            #define 预处理变量
            #ifdef 预处理变量：当且仅当变量已定义时为真
            #ifndef 预处理变量：当且仅当变量未定义时为真
            #endif：一旦检查结果为真，则执行直至#endif，否则跳过这部分。
        *注：头文件保护符要习惯性加好
            预处理变量无视作用域规则，名字全部大写
            
第三章：字符串、向量和数组

3.1 命名空间的using声明

（1）每个using声明引入命名空间中的一个成员。
      using namespace::name;
（2）头文件不应包含using声明

3.2 标准库类型string

（1）声明：using std::string;
（2）初始化string对象的方式：
      string s1;//默认初始化
      string s2(s1);//s2是s1的副本
      string s2 = s1;//与上一行等价
      string s3("value");//s3是字面值"value"的副本，除了字面值最后的'\0'
      string s3 = "value";//与上一行等价
      string s4(n,'c');//s4初始化为连续n个字符c组成的串
（3）直接初始化：不用=，初始化用到一个或多个值时
    拷贝初始化：用=，只适用于初始化用一个值
（4）string的操作：
      cin >> s;//忽略开头的空白（空格符、换行符、制表符等），直到下一处空白
      #include <string>
      cout << s << endl;//cout重载的是<string>头文件中，要先include才能用cout输出string
      while(cin >> str)//反复读取直到文件末尾
      getline(istream,s);//从输入流读一行给s，返回输入流。直到读到换行符结束，换行符已读，但不会存入字符串。
      s.empty()//空返回true，否则返回false
      s.size()//返回s中字符的个数
（5）string::size_type类型：size函数的返回值类型，足够大的无符号类型。
（6）string的比较运算符：
      如果长度不同，但从第一个字符起对应字符都相同，短的<长的
      如果字符不是一一对应，则比较第一个相异的字符的ASCII码
（7）string对象和字符串字面值
      为了与C兼容，还有某些历史原因，C++中的字符串字面值并不是string类型的对象，是不同的类型。
      标准库允许把字符字面值和字符串字面值转换成string对象，但连接时保证每个‘+’两边至少有一个是string对象，要考虑运算从左到右执行的顺序
      string s1 = "hello", s2 = "world";
      string s3 = s1 + "," + "world";//正确
      string s4 = "hello" + "," + s2;//错误
（8）cctype头文件中，定义了一组标准库函数，能获取（返回bool）和改变某个字符的特性（P82）
（9）处理每个字符：使用基于范围的for语句（类似C#中的foreach）
      for(declaration:expression)//前者为每个元素，用auto定义较为方便；后者为要读的字符串
            statement;
            *注：改变字符串中的字符，需要将循环变量声明为引用类型，即绑定在每个元素上
                 范围for循环体内不应改变其遍历序列的大小
（10）只处理一部分字符：下标运算符"[]"
      接收参数是string::size_type类型，所以不会小于0，只需要注意小于size()，可以总是传入这个类型；
      返回参数是该位置上字符的引用，所以可以直接改变下标指向的字符；
      下标必须大于0，小于s.size()，即只能对已存在的元素执行下标操作，否则将引发不可预知的结果，所以空string不可用下标访问
      
3.3 标准库类型vector

（1）定义：表示对象的集合，其中所有对象类型相同，每个对象有与之对应的索引。
（2）C++有类模板和函数模板，vector是类模板，编译器根据模板创建类或函数的过程为实例化。编译器需要提供信息来制定模板实例化成什么样的类，提供信息的方式：模板名字后面跟一对尖括号，括号内放上信息。
      vector<int> i;
      vector<vector<string>>;//元素是vector对象，老标准中后面两个尖括号之间要有空格
（3）vector初始化：
      vector<T> v1 //空vector，潜在元素类型为T，默认初始化
      vector<T> v2(v1)
      vector<T> v2 = v1 //同上
      vector<T> v3(n,val) //n个重复的值为val的元素
      vector<T> v4(n) //n个重复的执行过值初始化的元素
      vector<T> v5{a,b,c...}
      vector<T> v6 = {a,b,c...} //同上
      *注：几种初始化的方式
            int i = 0;//使用等号为拷贝初始化
            int i = {0};
            int i{0};//使用花括号为列表初始化
            int i(0);
      大多数情况下这几种初始化方式可以相互等价地使用，几种例外情况是：
            1.使用拷贝初始化时，只能提供一个初始值
            2.如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化
            3.如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能使用圆括号
      值初始化：通常情况下，可以只提供元素数量而略去初始值，由类默认初始化。
            有两个特殊限制：
            1.有些类要求必须明确提供初始值，否则无法完成初始化
            2.如果只提供了元素的数量而没有设定初始值，只能使用直接初始化
      区分列表初始值和元素数量：
            1.某些情况下，初始化的真实含义依赖于传递初始值时用的是圆括号还是花括号
                  vector<int> v1{10} //1个元素，初始值为10
                  vector<int> v2(10) //10个元素，初始值为0
                  vector<int> v3{10,1} //2个元素，为10和1
                  vector<int> v4(10,1) //10个元素，都为1
                  圆括号是用来构造（construct）vector的，花括号是用来列表初始化（list initialize）vector的
            2.当花括号提供的值不能用来初始化，编译器才会考虑尝试构造vector对象
                  vector<string> v5{10} //int不能赋给string，所以初始化为10个空串
（4）向vector对象中添加元素：push_back成员函数
      *注：vector对象能高效增长，所以通常都是创建一个空vector对象，再后续增加元素，性能更快。
           vector其他基本操作与string类似

3.4 迭代器

（1）定义：迭代器是一种机制，用来访问string对象的字符或vector对象的元素，所有标准库容器都可以使用迭代器。
（2）使用迭代器：通过类型拥有的能返回迭代器的成员，比如begin和end。
      begin：返回指向第一个元素（或第一个字符）的迭代器，类似指针。
      end：返回指向容器（或string对象）的为元素的下一位置的迭代器，即并不存在的“尾后”元素，没有实际意义，仅仅是个标记。
      当容器为空时，begin和end返回同一个迭代器，可用于判断。
（3）迭代器运算符：
      *iter//返回迭代器iter所指元素
      iter->mem//解引用iter并获得该元素的名为mem的成员，等价于(*iter).mem
      ++iter//令iter指向容器中的下一个元素
      --iter//令iter指向容器中的上一个元素
      iter1 == iter2
      iter1 != iter2//如果指向相同元素或是同一个容器的尾后迭代器，则相等，否则不等
    *注：迭代器使用递增运算符++，与整数的递增类似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。
      for中判断迭代器未到达容器尾：it != v.end()
    *注：关键概念-泛型编程，for中使用!=而不是<，因为前者在标准库提供的所有容器上都有效，而后者不是，这样就不用在意容器的类型。
（4）迭代器类型：
      一般来说，类似string和vector的size_type成员，我们也不知道（无需知道）迭代器的精准类型。其实在拥有迭代器的容器中，使用iterator和const_iterator来表示迭代器的类型，与指针和常量指针类似。
      string::iterator it;
      vector<int>::const_iterator it;
      begin和end返回的具体类型，通常由对象是否为常量决定。但有时只需读操作而不需要写操作时，最好使用常量类型，可以使用cbegin和cend，无论对象本身是否是常量，都返回const_iterator。
（5）结合解引用访问成员
      (*it).empty();//解引用it，调用返回结果对象的成员empty
      *it.empty();//错误。这样会由it来执行点运算符，访问it的empty成员，但迭代器it并没有这个成员，返回错误
      it->empty();//箭头运算符的简化形式 
（6）某些对vector对象的操作会使迭代器失效
      之前说过范围for循环中不能向vector对象添加元素；
      另一个限制，任何一种可能改变vector对象容量的操作，比如push_back，都会使vector对象的迭代器失效。
      *注：谨记，任何使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
（7）迭代器运算
      string和vector的迭代器提供了更多额外的运算符，可跨过多个元素，也可进行关系运算。
      iter + n;
      iter - n;//返回结果还是迭代器，比运算之前移动了若干个元素，结果指向容器的一个元素或指向容器尾元素的下一个位置
      iter += n;
      iter -= n;//运算同上，并把结果返回iter
      iter1 - iter2;//iter2到iter1要移动的元素个数，两个迭代器必须指向同一个容器
      >,>=,<,<= //迭代器的关系运算
   *注：n的类型是difference_type，带符号型整数
        二分搜索时，中点用mid = beg + (end - beg)/2;而不是mid = (beg + end)/2;因为迭代器之间加减没有意义，要用“旧迭代器+距离”得到中点迭代器

3.5 数组

（1）类似vector，但与其不同的地方在于，数组的大小确定不变，在运行某些特殊的应用时性能较好，但也损失了灵活性。如果不确定元素的确切个数，用vector。
（2）定义：形如a[d]，a为名字，d为维度。d>0，且应为常量表达式。
      一般来说，数组的元素会被默认初始化。但与内置类型的变量一样，函数内定义某种内置类型的数组，会含有未定义的值。
      不允许使用auto交给编译器判断类型。
      与vector类似，数组的元素为对象，所以没有引用的数组。
（3）显式初始化数组元素：
      int a1[] = {1, 2, 3};//列表初始化，可忽略维度
      int a2[5] = {1, 2, 3};//维度必须大于等于初始化列表中元素个数，未被赋值的被默认初始化，a2[] = {1, 2, 3, 0, 0}
（4）字符数组的特殊性：
      char a1[] = {'c','+','+'};//可以用字符初始化
      char a2[] = {'c','+','+','\0'};//含有显式空字符
      char a3[] = "c++";//用字符串字面值初始化，自动添加表示字符串结束的空字符，维度为4
      const char a4[3] = "c++";//错误！没有空间存放空字符'\0'
（5）不允许用数组为数组初始化或赋值
（6）理解复杂的数组声明：
      int *ptrs[10];//含有10个整型指针的数组
                    //不存在引用的数组
      int (*parray)[10] = &arr;//parray指向一个含有10个整数的数组
      int (&arrRef)[10] = arr;//arrRef引用一个含有10个整数的数组
      int *(&arry)[10] = ptrs;//arry是数组的引用，这个数组含有10个整型指针
   *注：理解数组声明的含义，最好的办法是从数组的名字开始，从内向外读
（7）访问数组元素：
      与vector一样，使用范围for语句或下标运算符[]来访问元素，下标类型为size_t，索引从0开始。
      另一点细微的区别：数组的下标运算符是C++直接定义，可以用在数组类型的运算对象；vector的下标运算符是库模板vector定义的，只能用于vector类型的对象
      
