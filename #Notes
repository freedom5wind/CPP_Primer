第一章：开始

1.while(std:cin >> value)读输入流，直到文件结束符(end-of-file)，在Windows中是Ctrl+Z+Enter。
2.输入输出流
      std::cout << "Hello world" << std::endl;
      int v0,v1;
      std::cin >> v0 >> v1;

第二章：变量和基本类型

当第一次使用变量时，再定义。

作用域操作符“::”用来说明想使用的作用域，当::左面为空时，即使用全局作用域。

##复合类型-引用和指针
复合类型：
声明语句应该由一个基本数据类型，和紧随其后的一个声明符列表组成。其中声明符一般指变量名，还有&、*等。*和&一次只修饰一个变量，即int* p和int *p的含义是一样的。

引用：
（1）用‘&’定义。
      例：int i,&j = i;//定义int变量i，定义int引用j绑定i
（2）定义的同时必须与一个对象绑定即初始化
（3）一般来说，引用与绑定的对象类型要相同。
    第一种例外：初始化常量引用时，允许用任意表达式作为初始值，基本数据类型可以不一样，只要该表达式的结果能转换成引用的类型即可。这时编译器用一个与引用同类型的临时量对象先暂存const对象并转换类型，然后将临时量赋给常量引用。
    常量引用，即对const的引用，引用被const修饰，被引用的对象不一定要有const修饰，常量引用不能改变其引用的变量的值，与引用对象本身是否是常量无关。
      int i;
      const int j;
      double k;
      const int &r1 = i;//非常量变量也可以用常量引用
      const int &r2 = j;//常量变量，只能用常量引用
      const int $r3 = k;//引用与被引用对象类型不同：const int temp = k; const int &r3 = temp;
（4）无法定义引用的引用，将会绑定到同一个对象
（5）引用本身不是一个对象，一旦定义了一个引用，就无法令其再绑定到另外的对象
（6）非常量引用的初始值必须为左值，常量引用的初始值可以是字面量。

指针：
（1）用‘*’定义。
（2）与内置类型相似，可以反复拷贝，无需在定义时赋初值。
（3）获取指针存放的地址，用取地址符‘&’
（4）访问指针指向的对象，用解引用符‘*’
（5）空指针，建议赋值为nullptr
（6）一般来说，指针和其指向的对象的类型应该一致。
    第一种例外：允许一个指向常量的指针指向一个非常量对象，但基本数据类型仍要一致。因为指针本身也是一个对象，修饰指针的const只能限定指针指向的地址不能修改，而被指向对象用const修饰，才能保证该对象不被修改。
      int i = 3;
      int *const p = &i;//i可以修改，p不能修改。另外注意const的位置，强调修饰的是指针本身
      const int j = 3;
      int *const p2 = &j;//常量只能用常量指针来指向，这时p2和j都不能修改。
      例：给指针赋值
      初始化时：
        int j = 1;
        int *p1 = &j;//将地址赋值给指针
        int *p2 = p1;//将指针的值，还是地址，赋给新的指针
      初始化后：
        int i = 3;
        int *p1, *p2;
        p1 = &i;//将i的地址赋给p1指针
        *p2 = i;//将i的值赋给p2指向的变量，但此处会报错，因为p2未初始化，没有确定指向的变量
 
多个修饰符连写：
(1）指向指针的指针：
      int i = 1;
      int *p = &i;
      int **p2 = &p;
(2) 指向指针的引用：（引用不是对象，所以不能定义指向引用的指针）
      int i = 2;
      int *p = &i;
      int *&r = p;//之后使用r就是使用p
注：面对比较复杂的指针或引用的声明语句时，将“基本数据类型”+“声明符列表”从右向左读有助于弄清含义。

const限定符：
（1）顶层const：表示指针本身是常量，也可以表示任意的对象是常量。
（2）底层const：表示指针指向的对象是一个常量。
     *注：指针既可以是顶层const，也可以是底层const。//const int *const p;第一个是底层，第二个是顶层。
（3）当执行对象的拷贝操作时，顶层const不受影响。而拷入拷出的对象都必须具有相同的底层const资格，或者将非常量转换为常量。
（4）常量表达式：指值不会改变并且在编译过程中就能得到计算结果的表达式。
      const int i = 3;//yes
      const int j = i + 2;//yes
      int k = 4;//no.没有用const修饰
      const int m = get_size();//no.值直到具体运行时才能得到
    用constexpr类型声明变量，让编译器方便验证是否为常量表达式。
      constexpr int s = size();//只有当size是一个constexpr函数时才是正确的语句
（5）字面值类型：常量表达式的值在编译时就要得到，所以constexpr修饰的类型要比较简单。
      算术类型、引用、指针都属于字面值类型。
      自定义类、IO库、string类不属于字面值类型。
      引用和指针被定义成constexpr时，初始值严格限制，如指针必须是nullptr或0或存储于某个固定地址中的对象。
      函数体内定义的变量一般不存储在固定地址，所以不能定义为constexpr，相反，函数体之外的对象都可以。另外函数可以定义一类有效范围超出函数本身的变量，可以定义为constexpr。
      constexpr定义指针时，仅对指针本身有效，即置为顶层const。
            const int *p1 = nullptr;//指向整型常量的指针
            constexpr int *p2 = nullptr;//指向整型的常量指针
            
2.5 处理类型
类型别名：
（1）定义：
      typedef double wages;//wages是double的同义词
      typedef double *p;//p是double* 的同义词
      using student_num = int;//student_num是int的同义词
            *注：typedef定义的是类型别名，引用&定义的是变量别名，两者不同。
（2）指针、常量和类型别名
      typedef char *pstring;
      const pstring cstr = 0;//cstr是指向char的常量指针
      const pstring *p;//p是一个指针，它的对象是指向char的常量指针，即p是指针的指针
      *注：不要随意把别名替换为本来的样子
            const pstring cstr = 0;//基本类型为const pstring，即声明了一个指向char的常量指针
            const char *cstr = 0;//基本类型为const char，即声明了一个指向const char的指针
            
auto类型说明符
（1）根据变量的初始值自动判断类型，即auto定义的变量必须有初始值。
      auto i = 0, *p = &i;//一条声明语句只有一个基本数据类型，所以声明的变量的初始值必须一致。
（2）对auto类型的初始值，为引用时，auto判断为引用的对象的类型。
（3）对auto类型的初始值，会被忽略掉顶层const属性，同时底层const会保存下来。
      如果希望判断出的auto类型是一个顶层const，需要用const明确指出。
      const auto f = ci;
（4）可以将引用的类型设为auto，初始值即被引用的对象的顶层const仍保留。
      auto &i = j;
      
decltype类型指示符
（1）作用：从表达式的类型推断出要定义的变量的类型，而不把表达式的值用来初始化该变量。
（2）与auto不同，decltype使用的表达式是变量时，返回该变量的类型，包括顶层const和引用。
      *注：引用从来都作为其所指对象的同义词出现，只有在decltype中例外。
（3）decltype返回引用类型的几种情况：
      int j = 3, &i = j, *p = &j;
      decltype(i) a;//使用的表达式为引用
      decltype(*p) b;//使用的表达式为解引用操作，这里得到int&
      decltype((i)) c;//使用的表达式为变量，但加上了一层或多层括号，被当作表达式，变量是一种可以作为赋值语句左值的特殊表达式，得到int&
                      //或者说，decltype使用双层括号时，结果永远是引用，单层括号只有表达式本身就是引用时结果才是引用
                      
2.6 自定义数据结构
自定义数据类型：
（1）定义：
      struct 类名{
            类体；
      };
（2）类内数据成员可以默认初始化，或者给一个类内初始值。
（3）编写头文件：保持一致性，通常包含那些只被定义一次的实体，如类、const、constexpr等，也经常用到其他头文件。
      *注：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。
（4）预处理器：处理一些预处理功能，在编译之前。
      #include
      #define
      头文件保护符：
            #define 预处理变量
            #ifdef 预处理变量：当且仅当变量已定义时为真
            #ifndef 预处理变量：当且仅当变量未定义时为真
            #endif：一旦检查结果为真，则执行直至#endif，否则跳过这部分。
        *注：头文件保护符要习惯性加好
            预处理变量无视作用域规则，名字全部大写
            
第三章：字符串、向量和数组

3.1 命名空间的using声明
（1）每个using声明引入命名空间中的一个成员。
      using namespace::name;
（2）头文件不应包含using声明

3.2 标准库类型string
（1）声明：using std::string;
（2）初始化string对象的方式：
      string s1;//默认初始化
      string s2(s1);//s2是s1的副本
      string s2 = s1;//与上一行等价
      string s3("value");//s3是字面值"value"的副本，除了字面值最后的'\0'
      string s3 = "value";//与上一行等价
      string s4(n,'c');//s4初始化为连续n个字符c组成的串
（3）直接初始化：不用=，初始化用到一个或多个值时
    拷贝初始化：用=，只适用于初始化用一个值
（4）string的操作：
      cin >> s;//忽略开头的空白（空格符、换行符、制表符等），直到下一处空白
      #include <string>
      cout << s << endl;//cout重载的是<string>头文件中，要先include才能用cout输出string
      while(cin >> str)//反复读取直到文件末尾
      getline(istream,s);//从输入流读一行给s，返回输入流。直到读到换行符结束，换行符已读，但不会存入字符串。
      s.empty()//空返回true，否则返回false
      s.size()//返回s中字符的个数
（5）string::size_type类型：size函数的返回值类型，足够大的无符号类型。
（6）string的比较运算符：
      如果长度不同，但从第一个字符起对应字符都相同，短的<长的
      如果字符不是一一对应，则比较第一个相异的字符的ASCII码
（7）string对象和字符串字面值
      为了与C兼容，还有某些历史原因，C++中的字符串字面值并不是string类型的对象，是不同的类型。
      标准库允许把字符字面值和字符串字面值转换成string对象，但连接时保证每个‘+’两边至少有一个是string对象，要考虑运算从左到右执行的顺序
      string s1 = "hello", s2 = "world";
      string s3 = s1 + "," + "world";//正确
      string s4 = "hello" + "," + s2;//错误
（8）cctype头文件中，定义了一组标准库函数，能获取（返回bool）和改变某个字符的特性（P82）
（9）处理每个字符：使用基于范围的for语句（类似C#中的foreach）
      for(declaration:expression)//前者为每个元素，用auto定义较为方便；后者为要读的字符串
            statement;
            *注：改变字符串中的字符，需要将循环变量声明为引用类型，即绑定在每个元素上
（10）只处理一部分字符：下标运算符"[]"
      接收参数是string::size_type类型，所以不会小于0，只需要注意小于size()，可以总是传入这个类型；
      返回参数是该位置上字符的引用，所以可以直接改变下标指向的字符；
      下标必须大于0，小于s.size()，否则将引发不可预知的结果，所以空string不可用下标访问
      
3.3 标准库类型vector

