第一章：开始

1.while(std:cin >> value)读输入流，直到文件结束符(end-of-file)，在Windows中是Ctrl+Z+Enter。
2.输入输出流
      std::cout << "Hello world" << std::endl;
      int v0,v1;
      std::cin >> v0 >> v1;

第二章：变量和基本类型

当第一次使用变量时，再定义。

作用域操作符“::”用来说明想使用的作用域，当::左面为空时，即使用全局作用域。

##复合类型-引用和指针
复合类型：
声明语句应该由一个基本数据类型，和紧随其后的一个声明符列表组成。其中声明符一般指变量名，还有&、*等。*和&一次只修饰一个变量，即int* p和int *p的含义是一样的。

引用：
（1）用‘&’定义。
      例：int i,&j = i;//定义int变量i，定义int引用j绑定i
（2）定义的同时必须与一个对象绑定即初始化
（3）一般来说，引用与绑定的对象类型要相同。
    第一种例外：初始化常量引用时，允许用任意表达式作为初始值，基本数据类型可以不一样，只要该表达式的结果能转换成引用的类型即可。这时编译器用一个与引用同类型的临时量对象先暂存const对象并转换类型，然后将临时量赋给常量引用。
    常量引用，即对const的引用，引用被const修饰，被引用的对象不一定要有const修饰，常量引用不能改变其引用的变量的值，与引用对象本身是否是常量无关。
      int i;
      const int j;
      double k;
      const int &r1 = i;//非常量变量也可以用常量引用
      const int &r2 = j;//常量变量，只能用常量引用
      const int $r3 = k;//引用与被引用对象类型不同：const int temp = k; const int &r3 = temp;
（4）无法定义引用的引用，将会绑定到同一个对象
（5）引用本身不是一个对象，一旦定义了一个引用，就无法令其再绑定到另外的对象
（6）非常量引用的初始值必须为左值，常量引用的初始值可以是字面量。
（7）当对象很大，而又不需要对对象进行写操作时，为了避免拷贝，可以使用引用。

指针：
（1）用‘*’定义。
（2）与内置类型相似，可以反复拷贝，无需在定义时赋初值。
（3）获取指针存放的地址，用取地址符‘&’
（4）访问指针指向的对象，用解引用符‘*’
（5）空指针，建议赋值为nullptr
（6）一般来说，指针和其指向的对象的类型应该一致。
    第一种例外：允许一个指向常量的指针指向一个非常量对象，但基本数据类型仍要一致。因为指针本身也是一个对象，修饰指针的const只能限定指针指向的地址不能修改，而被指向对象用const修饰，才能保证该对象不被修改。
      int i = 3;
      int *const p = &i;//i可以修改，p不能修改。另外注意const的位置，强调修饰的是指针本身
      const int j = 3;
      int *const p2 = &j;//常量只能用常量指针来指向，这时p2和j都不能修改。
      例：给指针赋值
      初始化时：
        int j = 1;
        int *p1 = &j;//将地址赋值给指针
        int *p2 = p1;//将指针的值，还是地址，赋给新的指针
      初始化后：
        int i = 3;
        int *p1, *p2;
        p1 = &i;//将i的地址赋给p1指针
        *p2 = i;//将i的值赋给p2指向的变量，但此处会报错，因为p2未初始化，没有确定指向的变量
 
多个修饰符连写：
(1）指向指针的指针：
      int i = 1;
      int *p = &i;
      int **p2 = &p;
(2) 指向指针的引用：（引用不是对象，所以不能定义指向引用的指针）
      int i = 2;
      int *p = &i;
      int *&r = p;//之后使用r就是使用p
注：面对比较复杂的指针或引用的声明语句时，将“基本数据类型”+“声明符列表”从右向左读有助于弄清含义。

const限定符：
（1）顶层const：表示指针本身是常量，也可以表示任意的对象是常量。
（2）底层const：表示指针指向的对象是一个常量。
     *注：指针既可以是顶层const，也可以是底层const。//const int *const p;第一个是底层，第二个是顶层。
（3）当执行对象的拷贝操作时，顶层const不受影响。而拷入拷出的对象都必须具有相同的底层const资格，或者将非常量转换为常量。
（4）常量表达式：指值不会改变并且在编译过程中就能得到计算结果的表达式。
      const int i = 3;//yes
      const int j = i + 2;//yes
      int k = 4;//no.没有用const修饰
      const int m = get_size();//no.值直到具体运行时才能得到
    用constexpr类型声明变量，让编译器方便验证是否为常量表达式。
      constexpr int s = size();//只有当size是一个constexpr函数时才是正确的语句
（5）字面值类型：常量表达式的值在编译时就要得到，所以constexpr修饰的类型要比较简单。
      算术类型、引用、指针都属于字面值类型。
      自定义类、IO库、string类不属于字面值类型。
      引用和指针被定义成constexpr时，初始值严格限制，如指针必须是nullptr或0或存储于某个固定地址中的对象。
      函数体内定义的变量一般不存储在固定地址，所以不能定义为constexpr，相反，函数体之外的对象都可以。另外函数可以定义一类有效范围超出函数本身的变量，可以定义为constexpr。
      constexpr定义指针时，仅对指针本身有效，即置为顶层const。
            const int *p1 = nullptr;//指向整型常量的指针
            constexpr int *p2 = nullptr;//指向整型的常量指针
            
2.5 处理类型
类型别名：
（1）定义：
      typedef double wages;//wages是double的同义词
      typedef double *p;//p是double* 的同义词
      using student_num = int;//student_num是int的同义词
            *注：typedef定义的是类型别名，引用&定义的是变量别名，两者不同。
（2）指针、常量和类型别名
      typedef char *pstring;
      const pstring cstr = 0;//cstr是指向char的常量指针
      const pstring *p;//p是一个指针，它的对象是指向char的常量指针，即p是指针的指针
      *注：不要随意把别名替换为本来的样子
            const pstring cstr = 0;//基本类型为const pstring，即声明了一个指向char的常量指针
            const char *cstr = 0;//基本类型为const char，即声明了一个指向const char的指针
            
auto类型说明符
（1）根据变量的初始值自动判断类型，即auto定义的变量必须有初始值。
      auto i = 0, *p = &i;//一条声明语句只有一个基本数据类型，所以声明的变量的初始值必须一致。
（2）对auto类型的初始值，为引用时，auto判断为引用的对象的类型。
（3）对auto类型的初始值，会被忽略掉顶层const属性，同时底层const会保存下来。
      如果希望判断出的auto类型是一个顶层const，需要用const明确指出。
      const auto f = ci;
（4）可以将引用的类型设为auto，初始值即被引用的对象的顶层const仍保留。
      auto &i = j;
      
decltype类型指示符
（1）作用：从表达式的类型推断出要定义的变量的类型，而不把表达式的值用来初始化该变量。
（2）与auto不同，decltype使用的表达式是变量时，返回该变量的类型，包括顶层const和引用。
      *注：引用从来都作为其所指对象的同义词出现，只有在decltype中例外。
（3）decltype返回引用类型的几种情况：
      int j = 3, &i = j, *p = &j;
      decltype(i) a;//使用的表达式为引用
      decltype(*p) b;//使用的表达式为解引用操作，这里得到int&
      decltype((i)) c;//使用的表达式为变量，但加上了一层或多层括号，被当作表达式，变量是一种可以作为赋值语句左值的特殊表达式，得到int&
                      //或者说，decltype使用双层括号时，结果永远是引用，单层括号只有表达式本身就是引用时结果才是引用
                      
2.6 自定义数据结构
自定义数据类型：
（1）定义：
      struct 类名{
            类体；
      };
（2）类内数据成员可以默认初始化，或者给一个类内初始值。
（3）编写头文件：保持一致性，通常包含那些只被定义一次的实体，如类、const、constexpr等，也经常用到其他头文件。
      *注：头文件一旦改变，相关的源文件必须重新编译以获取更新过的声明。
（4）预处理器：处理一些预处理功能，在编译之前。
      #include
      #define
      头文件保护符：
            #define 预处理变量
            #ifdef 预处理变量：当且仅当变量已定义时为真
            #ifndef 预处理变量：当且仅当变量未定义时为真
            #endif：一旦检查结果为真，则执行直至#endif，否则跳过这部分。
        *注：头文件保护符要习惯性加好
            预处理变量无视作用域规则，名字全部大写
            
第三章：字符串、向量和数组

3.1 命名空间的using声明

（1）每个using声明引入命名空间中的一个成员。
      using namespace::name;
（2）头文件不应包含using声明

3.2 标准库类型string

（1）声明：using std::string;
（2）初始化string对象的方式：
      string s1;//默认初始化
      string s2(s1);//s2是s1的副本
      string s2 = s1;//与上一行等价
      string s3("value");//s3是字面值"value"的副本，除了字面值最后的'\0'
      string s3 = "value";//与上一行等价
      string s4(n,'c');//s4初始化为连续n个字符c组成的串
（3）直接初始化：不用=，初始化用到一个或多个值时
    拷贝初始化：用=，只适用于初始化用一个值
（4）string的操作：
      cin >> s;//忽略开头的空白（空格符、换行符、制表符等），直到下一处空白
      #include <string>
      cout << s << endl;//cout重载的是<string>头文件中，要先include才能用cout输出string
      while(cin >> str)//反复读取直到文件末尾
      getline(istream,s);//从输入流读一行给s，返回输入流。直到读到换行符结束，换行符已读，但不会存入字符串。
      s.empty()//空返回true，否则返回false
      s.size()//返回s中字符的个数
（5）string::size_type类型：size函数的返回值类型，足够大的无符号类型。
（6）string的比较运算符：
      如果长度不同，但从第一个字符起对应字符都相同，短的<长的
      如果字符不是一一对应，则比较第一个相异的字符的ASCII码
（7）string对象和字符串字面值
      为了与C兼容，还有某些历史原因，C++中的字符串字面值并不是string类型的对象，是不同的类型。
      标准库允许把字符字面值和字符串字面值转换成string对象，但连接时保证每个‘+’两边至少有一个是string对象，要考虑运算从左到右执行的顺序
      string s1 = "hello", s2 = "world";
      string s3 = s1 + "," + "world";//正确
      string s4 = "hello" + "," + s2;//错误
（8）cctype头文件中，定义了一组标准库函数，能获取（返回bool）和改变某个字符的特性（P82）
（9）处理每个字符：使用基于范围的for语句（类似C#中的foreach）
      for(declaration:expression)//前者为每个元素，用auto定义较为方便；后者为要读的字符串
            statement;
            *注：改变字符串中的字符，需要将循环变量声明为引用类型，即绑定在每个元素上
                 范围for循环体内不应改变其遍历序列的大小
（10）只处理一部分字符：下标运算符"[]"
      接收参数是string::size_type类型，所以不会小于0，只需要注意小于size()，可以总是传入这个类型；
      返回参数是该位置上字符的引用，所以可以直接改变下标指向的字符；
      下标必须大于0，小于s.size()，即只能对已存在的元素执行下标操作，否则将引发不可预知的结果，所以空string不可用下标访问
      
3.3 标准库类型vector

（1）定义：表示对象的集合，其中所有对象类型相同，每个对象有与之对应的索引。
（2）C++有类模板和函数模板，vector是类模板，编译器根据模板创建类或函数的过程为实例化。编译器需要提供信息来制定模板实例化成什么样的类，提供信息的方式：模板名字后面跟一对尖括号，括号内放上信息。
      vector<int> i;
      vector<vector<string>>;//元素是vector对象，老标准中后面两个尖括号之间要有空格
（3）vector初始化：
      vector<T> v1 //空vector，潜在元素类型为T，默认初始化
      vector<T> v2(v1)
      vector<T> v2 = v1 //同上
      vector<T> v3(n,val) //n个重复的值为val的元素
      vector<T> v4(n) //n个重复的执行过值初始化的元素
      vector<T> v5{a,b,c...}
      vector<T> v6 = {a,b,c...} //同上
      *注：几种初始化的方式
            int i = 0;//使用等号为拷贝初始化
            int i = {0};
            int i{0};//使用花括号为列表初始化
            int i(0);
      大多数情况下这几种初始化方式可以相互等价地使用，几种例外情况是：
            1.使用拷贝初始化时，只能提供一个初始值
            2.如果提供的是一个类内初始值，则只能使用拷贝初始化或使用花括号的形式初始化
            3.如果提供的是初始元素值的列表，则只能把初始值都放在花括号里进行列表初始化，而不能使用圆括号
      值初始化：通常情况下，可以只提供元素数量而略去初始值，由类默认初始化。
            有两个特殊限制：
            1.有些类要求必须明确提供初始值，否则无法完成初始化
            2.如果只提供了元素的数量而没有设定初始值，只能使用直接初始化
      区分列表初始值和元素数量：
            1.某些情况下，初始化的真实含义依赖于传递初始值时用的是圆括号还是花括号
                  vector<int> v1{10} //1个元素，初始值为10
                  vector<int> v2(10) //10个元素，初始值为0
                  vector<int> v3{10,1} //2个元素，为10和1
                  vector<int> v4(10,1) //10个元素，都为1
                  圆括号是用来构造（construct）vector的，花括号是用来列表初始化（list initialize）vector的
            2.当花括号提供的值不能用来初始化，编译器才会考虑尝试构造vector对象
                  vector<string> v5{10} //int不能赋给string，所以初始化为10个空串
（4）向vector对象中添加元素：push_back成员函数
      *注：vector对象能高效增长，所以通常都是创建一个空vector对象，再后续增加元素，性能更快。
           vector其他基本操作与string类似

3.4 迭代器

（1）定义：迭代器是一种机制，用来访问string对象的字符或vector对象的元素，所有标准库容器都可以使用迭代器。
（2）使用迭代器：通过类型拥有的能返回迭代器的成员，比如begin和end。
      begin：返回指向第一个元素（或第一个字符）的迭代器，类似指针。
      end：返回指向容器（或string对象）的为元素的下一位置的迭代器，即并不存在的“尾后”元素，没有实际意义，仅仅是个标记，也称尾后迭代器。
      当容器为空时，begin和end返回同一个迭代器，可用于判断。
（3）迭代器运算符：
      *iter//返回迭代器iter所指元素
      iter->mem//解引用iter并获得该元素的名为mem的成员，等价于(*iter).mem
      ++iter//令iter指向容器中的下一个元素
      --iter//令iter指向容器中的上一个元素
      iter1 == iter2
      iter1 != iter2//如果指向相同元素或是同一个容器的尾后迭代器，则相等，否则不等
    *注：迭代器使用递增运算符++，与整数的递增类似，整数的递增是在整数值上“加1”，迭代器的递增则是将迭代器“向前移动一个位置”。
      for中判断迭代器未到达容器尾：it != v.end()
    *注：关键概念-泛型编程，for中使用!=而不是<，因为前者在标准库提供的所有容器上都有效，而后者不是，这样就不用在意容器的类型。
（4）迭代器类型：
      一般来说，类似string和vector的size_type成员，我们也不知道（无需知道）迭代器的精准类型。其实在拥有迭代器的容器中，使用iterator和const_iterator来表示迭代器的类型，与指针和常量指针类似。
      string::iterator it;
      vector<int>::const_iterator it;
      begin和end返回的具体类型，通常由对象是否为常量决定。但有时只需读操作而不需要写操作时，最好使用常量类型，可以使用cbegin和cend，无论对象本身是否是常量，都返回const_iterator。
（5）结合解引用访问成员
      (*it).empty();//解引用it，调用返回结果对象的成员empty
      *it.empty();//错误。这样会由it来执行点运算符，访问it的empty成员，但迭代器it并没有这个成员，返回错误
      it->empty();//箭头运算符的简化形式 
（6）某些对vector对象的操作会使迭代器失效
      之前说过范围for循环中不能向vector对象添加元素；
      另一个限制，任何一种可能改变vector对象容量的操作，比如push_back，都会使vector对象的迭代器失效。
      *注：谨记，任何使用了迭代器的循环体，都不要向迭代器所属的容器添加元素。
（7）迭代器运算
      string和vector的迭代器提供了更多额外的运算符，可跨过多个元素，也可进行关系运算。
      iter + n;
      iter - n;//返回结果还是迭代器，比运算之前移动了若干个元素，结果指向容器的一个元素或指向容器尾元素的下一个位置
      iter += n;
      iter -= n;//运算同上，并把结果返回iter
      iter1 - iter2;//iter2到iter1要移动的元素个数，两个迭代器必须指向同一个容器
      >,>=,<,<= //迭代器的关系运算
   *注：n的类型是difference_type，带符号型整数
        二分搜索时，中点用mid = beg + (end - beg)/2;而不是mid = (beg + end)/2;因为迭代器之间加减没有意义，要用“旧迭代器+距离”得到中点迭代器

3.5 数组

（1）类似vector，但与其不同的地方在于，数组的大小确定不变，在运行某些特殊的应用时性能较好，但也损失了灵活性。如果不确定元素的确切个数，用vector。
（2）定义：形如a[d]，a为名字，d为维度。d>0，且应为常量表达式。
      一般来说，数组的元素会被默认初始化。但与内置类型的变量一样，函数内定义某种内置类型的数组，会含有未定义的值。
      不允许使用auto交给编译器判断类型。
      与vector类似，数组的元素为对象，所以没有引用的数组。
（3）显式初始化数组元素：
      int a1[] = {1, 2, 3};//列表初始化，可忽略维度
      int a2[5] = {1, 2, 3};//维度必须大于等于初始化列表中元素个数，未被赋值的被默认初始化，a2[] = {1, 2, 3, 0, 0}
（4）字符数组的特殊性：
      char a1[] = {'c','+','+'};//可以用字符初始化
      char a2[] = {'c','+','+','\0'};//含有显式空字符
      char a3[] = "c++";//用字符串字面值初始化，自动添加表示字符串结束的空字符，维度为4
      const char a4[3] = "c++";//错误！没有空间存放空字符'\0'
（5）不允许用数组为数组初始化或赋值
（6）理解复杂的数组声明：
      int *ptrs[10];//含有10个整型指针的数组
                    //不存在引用的数组
      int (*parray)[10] = &arr;//parray指向一个含有10个整数的数组
      int (&arrRef)[10] = arr;//arrRef引用一个含有10个整数的数组
      int *(&arry)[10] = ptrs;//arry是数组的引用，这个数组含有10个整型指针
   *注：理解数组声明的含义，最好的办法是从数组的名字开始，从内向外读
（7）访问数组元素：
      与vector一样，使用范围for语句或下标运算符[]来访问元素，下标类型为size_t，索引从0开始。
      另一点细微的区别：数组的下标运算符是C++直接定义，可以用在数组类型的运算对象，使用的下标是带符号类型，可正可负；vector的下标运算符是库模板vector定义的，只能用于vector类型的对象，使用的下标是无符号类型。
（8）指针和数组：
      取地址符可用于任何对象，包括数组元素，获得一个指向该元素的指针；
            int nums[] = {1, 2, 3};
            int *p = &nums[0];
      很多用到数组名字的地方，编译器会自动将其替换为指向数组首元素的指针
            int *p2 = nums;//作用同上
      当使用数组作为auto变量的初始值时，得到的类型是指针而不是数组
            auto a1(nums);//得到整型指针，指向nums第一个元素
      使用decltype时，上述转换不会发生，返回类型为数组
            decltype(nums) a2 = {0, 1, 2};//相当于int a2[] = {0, 1, 2};a2不能被赋予整型指针
      指向数组元素的指针也是迭代器，支持迭代器的各种运算。
            获取首元素，可以用索引[0]；获取尾元素之后的地址，可以用索引[数组长度]，本身不存在，只是为了获取尾后指针。
            iterator头文件中定义了begin和end两个函数，返回指向首元素和尾元素后的指针。由于数组不是类类型，所以这两个函数并不是数组的成员函数，数组名应作为它们的参数。
                  int a0 = {1, 2, 3};
                  int *beg = begin(a0);
                  int *last = end(a0);
            两指针相减，得到的距离类型为ptrdiff_t的标准库带符号类型，可正可负。这个运算同样适用于空指针和所指对象并非数组的指针。在后一种情况下，两个指针必须指向同一个对象或该对象的下一位置；如果p是空指针，允许给p加上或减去一个值为0的整型常量表达式。两个空指针也允许彼此相减，结果为0。
      对于指向数组元素的指针，可以用解引用获得指向的元素本身。
      只要是指向数组元素的指针，就可以使用下标运算符。
            int a1[] = {2, 3, 4, 5};
            int *p = &a1[2];
            int i = p[1];//i = 5，相当于*(p + 1)
            int j = p[-1];//j = 3，相当于*(p - 1)，内置类型的下标运算符可以处理负值，与string和vector不一样
（9）C风格字符串：不推荐使用，见P109.
      内容有：C风格字符串的操作，C++与旧代码的接口。
（10）多维数组：严格来说，C++中并没有多维数组，只是数组的数组。
      多维数组的读法依然是从数组名开始，不断扩展。
            int a0[2][3][4];//a0是长度为2的数组，元素是长度为3的数组，每个数组含4个元素。
      多维数组初始化：
            可以只用一个花括号，则从首元素起逐个赋值，余下未赋值的元素默认初始化；也可以用内嵌花括号，表示内层数组，同样满足默认初始化规则。
      多维数组的下标引用：
            表达式的下标运算符数量，等于多维数组时，表示元素；小于时，表示内层数组。
      使用范围for语句处理多维数组：
            除了最内层循环外，auto类型的声明，要显式定义为引用，否则会返回类型指针，而不是内层数组。
                  for(auto &row : a)
                      for(auto col : row)
      使用多维数组的名字时，也会自动转换成指向数组首元素的指针，所以指针的类型定义要格外注意。
            int a[3][4];
            int (*p)[4] = a;//指向含4个元素的数组的指针
            auto *p = a;//用auto就可以忽略指针类型
            for(auto q1 a; q1 != a + 3; ++q1)
                  for(auto q2 *q1; q2 != *q1 + 4; ++q2)//*q1解引用，得到指向第一个数组的首元素的指针，即q2指向一个整数
            for(auto q1 = begin(a); q1 != end(a); ++q1)
                  for(auto q2 = begin(*q1); q2 != end(*q1); ++q2)//用begin和end函数，就不用关心数组长度问题
      也可以使用类型别名来化简多维数组的指针
            using int_array = int[4];
            typedef int int_array[4];//与上一行等价
            
第四章：表达式

4.1 基础
（1）基本概念
      一元运算符：作用于一个运算对象。如取地址符&，解引用符*
      二元运算符：作用于两个运算对象。如相等运算符==，乘法运算符*
      三元运算符：作用于三个运算对象。
      特殊的运算符：函数调用，对运算对象的数量没有限制。
      *注：一些运算符既是一元运算符也是二元运算符，如*（解引用+乘法运算），取决于它的上下文，两种用法互不相干。
      
      组合运算符和运算对象：对于包含多个运算符的复杂表达式，要理解运算符的优先级、结合律以及运算对象的求值顺序。
      运算对象类型转换：表达式求值时，运算对象常常转换类型，要了解类型转换规则。
      重载运算符：C++定义的运算符，作用于类类型的运算对象时，用户可以自定义其含义。可以自定义运算对象的类型和返回对象的类型，但运算对象个数、运算符的优先级和结合律都是无法改变的。
      左值和右值：C++中，左值右值的区分并不像C中那么简单，可以这样归纳，当一个对象被用作右值时，用的是对象的值（内容）；当对象被用作左值时，用的是对象的身份（在内存中的位置）。
      *注1：不同运算符对运算对象的要求各不同，有左值有右值。有一个重要的原则，可以用左值替代右值，即使用其内容，但不可用右值替代左值。（有一种例外）
      *注2：decltype关键字，使用的表达式求值结果是左值时，返回引用类型；求值结果是右值时，直接返回。
（2）优先级和结合律：P147表
      意义：规定了运算对象的组合方式，但没有规定运算对象的求值顺序
      先计算高优先级的运算符
      如果优先级相同，则按左结合律，即从左向右计算
      括号内为独立表达式，全部计算完后，结果代回原式
（3）求值顺序：在大多数情况下，不会明确运算对象的求值顺序。
      四种运算符规定了运算对象的求值顺序，从左到右：逻辑与&&    逻辑或||    条件?:     逗号,
   *注：处理复合表达式的两条经验准则：
      一.拿不准的时候，最好用括号来强制让表达式的组合关系符合程序逻辑的要求。
      二.如果改变了某个运算对象的值，在表达式的其他地方不要再使用这个运算对象。
            *第二条的一个重要例外：当改变运算对象的子表达式本身就是另外一个子表达式的运算对象时，该规则无效。
            例：*++iter;//首先要进行自增运算，才能进行解引用运算，顺序已经确定。
            
4.2 算术运算符

（1）包括：（优先级从高到低，全部满足左结合律）
      +：一元正号      -：一元负号
      *：乘法         /：除法        %：求余
      +：加法         -：减法
      注1：除非特殊说明，算术运算符能作用于任意算术类型以及任意能转换为算术类型的类型。
      注2：算术运算符的运算对象和求值结果都是右值
      注3：一元正号、加法、减法运算符都能作用于指针，返回一个（提升后的）副本
      注4：bool值一般不参与运算，容易出错
      注5：算术表达式可能产生未定义的结果，可能是由于数学性质本身，如除数为0；或由于计算机，比如溢出。
      注6：整数除法运算，余数直接舍弃，不会进位。
      注7：取余运算m%n，结果符号与m看齐，即m%(-n) = m%n; (-m)%n = -(m%n);
      
4.3 逻辑和关系运算符

（1）关系运算符作用于算术类型或指针类型，逻辑运算符作用于任意能转换成布尔值的类型。
    两者返回类型都是bool类型。
    值为0的对象表示假，否则表示真。
    运算对象和求值结果都是右值。
（2）包含：（优先级从高到低）
      !：逻辑非（唯一一个右结合律，以下都是左结合律）
      <：小于        <=：小于等于       >：大于        >=：大于等于
      ==：相等       !=：不相等
      &&：逻辑与
      ||：逻辑或
      注1：逻辑与和逻辑或，当且仅当左侧运算对象无法确定表达式结果时，才会计算右侧运算对象的值
